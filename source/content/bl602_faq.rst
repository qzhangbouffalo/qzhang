=============
芯片基本参数
=============

关于芯片架构
====================

CPU架构，运行频率以及RAM
------------------------------------

BL602是基于RISC-V处理器芯片，最高运行频率是160MHz,特殊情况下允许超频到192M，芯片可用RAM。

芯片从上电到运行程序最快需要多长时间？
-----------------------------------------
约3ms。

芯片掉电的时候，数据存储在哪里？
---------------------------------
完全掉电时，芯片内ram上的数据均会丢失。PDS、HBN模式不同level下ram区域掉电情况各不相同，需要case by case。

关于芯片时钟
==============

如果想给某一个外设配置时钟，需要调用哪些函数？
-----------------------------------------------
GLB_Set_System_CLK()            -->     设置整个系统的时钟，部分外设时钟也来源于此
GLB_Set_......_CLK()            -->     设置目标外设时钟
GLB_AHB_Slave1_Clock_Gate()     -->     部分外设时钟默认被gate，使用该外设时需要主动ungate
其它外设                        -->     目标外设内相关时钟配置

PDS、HBN的工作机制是什么？如何实现唤醒？
-------------------------------------------
将芯片划分为多个电源域，通过不同电源域掉电与否的组合来实现不同级别的低功耗模式，详情参见低RM功耗章节。
不同级别的低功耗模式唤醒源均不相同，详情参见低RM功耗章节。

芯片的功耗是多少？
---------------------
低负荷运行时电流在10mA左右，高负荷运行时电流40mA以上，低功耗模式最低可达2uA左右。

芯片的时钟源有哪些？
---------------------
外部XTAL、XTAL32K
内部RC32M、RC32K
内部PLL

==============
外设
==============

ADC的精度和采样率是多少？
================================
ADC实际精度为12BIT,当OSR=256,打开平均值滤波的时候可以达到16bit精度。
当ADC工作在非多通道扫描模式时,最大可支持2M采样率。如果是多通道扫描模式，最大支持1M采样率。

mtimer的作用是什么，它是如何工作的？
===========================================
MTimer为内核提供的一个timer，开启后实现计时功能，计数值与比较值寄存器位于内核，使用方式与一般timer无明显区别。

芯片包含几个timer?
=============================
1个64-bit mtimer，2个32-bit normal timer，1个16-bit watchdog timer。

看门狗的超时时间如何设置？超时的现象是什么？
====================================================
看门狗包含一个计数器和比较器，通过写入比较器的值，当计数器向上计数达到比较器的值时，会产生一个看门狗中断信号或者一个系统复位信号，具体产生哪种信号由用户自行设置。

GPIO的配置参数有哪些？如何配置？
=======================================
gpioPin  :  GPIO pin number， GPIO编号
gpioFun  :  GPIO function， GPIO功能
gpioMode :  input/output/af， 输入/输出/复用模式
pullType :  pull_up/pull_down/pull_none， 上拉/下拉/浮空
drive    :  drive strength， 驱动能力，数值越大驱动能力越强
smtCtrl  :  smt, 迟滞控制，建议设一
详情参见低RM GPIO章节。

GPIO的引脚在使用时有什么需要注意的？
==============================================
需要正确配置GPIO结构体，不建议同时使能input与output。

SPI一次最多发送多少字节？发送机制是什么？
==============================================
SPI一次可发送任意长度个字节，只需要保持tx fifo中有持续可用的数据，另外tx fifo的宽度可根据需要设置为8/16/24/32-bit。发送机制是：使能spi发送功能之后，tx fifo中的数据会按照设定的位宽和bit顺序进入移位寄存器中，然后按照极性和相位的设置在每一个时钟的上升沿/下降沿去改变MISO/MOSI的引脚电平将数据发送出去。例如CPOL=1，CPHA=1，则SPI时钟空闲时为高电平，数据在时钟的上升沿被送出。


===========
低功耗
===========

进入低功耗模式后电流异常
=============================
当正常进入PDS时电流一般100uA~200uA，正常进入HBN时电流一般<5uA，如果电流在几百uA则说明有power domain未关，如果电流超过10mA则一般是程序跑飞所导致的。

电流未能如期降低，直接升高到mA级别
====================================
当发现电流未能降低至uA级别就直接上升到10mA以上时，一般是程序跑飞导致，出现此问题优先考虑是否在PDS_Mode_Enter中关闭flash之后又访问了flash的地址0x23xxxxxx，可以通过反汇编对此进行确认，PDS_Mode_Enter内关flash与开flash之间绝不应该出现0x23xxxxxx地址。如果是此问题导致，则优先确认链接脚本中是否没把ATTR_CLOCK_SECTION、ATTR_CLOCK_CONST_SECTION、ATTR_TCM_SECTION、ATTR_TCM_CONST_SECTION、ATTR_DTCM_SECTION等放到TCM区域，其次确认此过程中是否有变量在flash上。还有可能是代码中所使用到的某些API没使用这些链接属性修饰。

能正常进入低功耗，但无法正常唤醒
===================================
需要确认所需中断是否正常配置（低功耗中断需要配置，相应外设中断也需要配置），查找问题时可以考虑使用PDS/HBN自身的timer唤醒来做对比验证，确认是没正确配置唤醒源还是确实PDS/HBN模式配置错误，然后继续查找原因。

在IOT_SDK运行异常，在MCU_SDK运行正常
=========================================
MCU_SDK平台相对简单，一般不会出现进出PDS/HBN异常的情况。IOT_SDK平台较为复杂，不过一般是因为其所使用的stddriver没有更新到最新版本所导致，因此IOT_SDK跑低功耗的case时需要优先更新stddriver到最新。（mcu_sdk使用a1分支，iot_sdk使用iot_sdk分支，merge操作也存在需要更新的情况，需要考虑到此点）

低功耗模式下电流比预期大了几十uA
=====================================
flash pad floating会导致漏电（50uA~100+uA）。faraday memory进行读写后无法正常进入retension模式会导致电流偏大（20uA左右）。进入低功耗后某些GPIO没有HighZ会导致电流增大。为了从低功耗模式唤醒所打开的外设会导致电流偏大（如HBN模式使用acomp唤醒）。

注意事项
=============
(1) 进入PDS前若关闭了flash，则需要保证关flash后的代码都不在flash上，否则跑飞。

(2) 若需要使用JLINK调试，则JLINK所用的GPIO不能被HighZ。

(3) 602使用的是faraday的memory，其特性为程序在将TCM/OCRAM设置为retension模式后如果又对TCM/OCRAM区域进行了写操作，则会导致这些区域自行退出retension模式，继而使得电流稍大（20uA级别）。

(4) sram有idle、retension、sleep三种模式，正常读写sram时其处于idle模式，idle模式电流较大，retension模式下不能对sram进行读写但此时进入低功耗后数据可以保留，retension模式电流较小，sleep模式下sram掉电所有数据全部丢失，sleep模式电流最小。

(5) PDS模式需要37个clock（32K）的时间来warm up，因此存在最小睡眠时间的限制37，软件结构体中的睡眠时间必须超过此数值。

(6) 当使用PDS的qon pad唤醒时，需要注意，由于ro_pds_irq_in中断会同时受到多个irq的影响而置一，因此在清此标志位之前，需要确保其所包含的多个irq都已经被clear掉，否则即使设置了cr_pds_int_clr，也会由于“hbn_irq_out | (gpio_irq) | irrx_int | ble_slp_irq | reg_en_platform_wakeup & platform_wake_up”而使得ro_pds_irq_in再次被置一（尤其是HBN内GPIO7/8的IRQ标志位），因此需要在设置aon pad唤醒PDS时，先清一下这些标志位。

(7) 只要唤醒源在(hbn_wakeup)，就没办法hbn sleep。所以当唤醒源标志位未清时，0x4000F000[7]置一并不会进入hbn，程序会继续向下运行。

(8) 为了避免因flash pad floating而导致的漏电，需要正确设置相应pad的pull，建议全部上拉。

(9) 在进入PDS/HBN之前需要确保相应低功耗模式下有效的唤醒源中断全都被清除过，否则有可能无法正常进入PDS/HBN。

(10) 在测试PDS/HBN时遇到异常现象时，建议优先接上电流表，可以方便排查问题。

===============
音频
===============
芯片是否支持播放/录音的功能，支持哪些常用的频率和位宽？

芯片内置12BIT ADC以及10bit DAC，可以通过ADC和DAC的基本功能配合推荐的功放/录音电路，完成播放和录音的功能。
最大支持16K采样率16bit位宽录音数据流
仅支持8K常用采样率16bit位宽播放，因为DAC的时钟仅支持32K 16K 8K 512K四种采样率可选，没有专业的audio PLL ，只有8K是常用的播放采样率，其他采样率不常用。

=============
Dev Cube工具
=============
MCU和IOT这两个界面有什么不同的功能？
==========================================

 - MCU界面适用于MCU类芯片，搭配MCU SDK一起使用
 - IOT界面适用于带无线功能的芯片，搭配IOT SDK一起使用

烧写时，可以自动选择flash嘛？
=======================================
烧写时，工具自动选择Flash，Flash选择优先级： 内封Flash Swap Pin > 内封FLash > 外置Flash GPIO 17-22 > 外置Flash GPIO 0-2&20-22。

波特率最大可以达到多少？
=================================
工具使用UART烧写时，建议的最大波特率可以达到2000000。

工具烧写1MB的文件，需要多久时间？
==================================
工具选择UART下载，波特率2000000时，向Winbond Flash烧写1MB文件耗时11秒左右。该时间仅供参考，会因为Flash型号的不同有小幅变化。

下载失败的原因有哪些？
=============================

 - 芯片没有从UART启动，导致工具和芯片握手失败
 - 工具界面选择不合理，晶振选错等
 - 烧写文件大小超过Flash可用容量
 - 使用外置Flash时，Flash有虚焊
 - 使用了工具暂不支持的Flash型号
 - Flash被写保护
 - 工具默认使用4线模式烧写Flash，有个别型号Flash最多只支持2线模式，这种情况需要做特殊配置才能正常烧写
 - 工具log界面提示“Verify fail”，需要确认硬件板子设计是否能支持高波特率下载

使用说明
=============
具体可参考《BLDevCube用户使用手册》。路径为：docs/BLDevCube用户使用手册.pdf。


=================
工厂批量烧写工具
=================
批量烧写工具支持哪些烧写模式
==============================

 - 单文件模式： 工具界面指定烧写文件和指定烧写地址，工具会将指定文件烧写到Flash指定地址上
 - 开发模式： 可以在配置文件中指定多个烧写文件和对应的烧写地址，工具会一次性烧写多个文件到Flash对应的烧写地址上
 - 动态模式： 支持动态生成烧写文件，适用于一机一码等烧写文件需要动态改变的场景，动态文件生成功能需要按具体需求定制


批量烧写工具对于芯片上电时序有什么样的要求？
=============================================
批量烧写工具在做烧写任务前，需要让芯片从UART启动。建议使用博流烧写板控制芯片的上电时序，确保批量生产时，烧写的稳定性。博流烧写板和烧写工具之前会有一套软硬件之间协同控制芯片上电时序的流程。

使用说明
=============
具体可参考《BL批量烧写工具使用手册》。










